<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>高解像度音声波形エディタ - 動画音声抽出システム</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css">
    <style>
        .waveform-container {
            position: relative;
            overflow: hidden;
            cursor: crosshair;
        }
        .playhead {
            position: absolute;
            width: 2px;
            background: #ef4444;
            pointer-events: none;
            z-index: 10;
        }
        .selection-overlay {
            position: absolute;
            background: rgba(59, 130, 246, 0.3);
            pointer-events: none;
            z-index: 5;
        }
        .time-marker {
            position: absolute;
            width: 1px;
            background: #6b7280;
            opacity: 0.5;
        }
        .volume-meter {
            background: linear-gradient(to right, #10b981 0%, #f59e0b 70%, #ef4444 100%);
        }
        .drag-handle {
            cursor: ew-resize;
        }
        input[type="range"] {
            -webkit-appearance: none;
            appearance: none;
            height: 6px;
            border-radius: 3px;
            background: #d1d5db;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
        }
        input[type="range"]::-moz-range-thumb {
            height: 18px;
            width: 18px;
            border-radius: 50%;
            background: #3b82f6;
            cursor: pointer;
            border: none;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen">
    <div class="container mx-auto px-4 py-8 max-w-6xl">
        <header class="text-center mb-8">
            <h1 class="text-4xl font-bold text-gray-800 mb-2">
                <i class="fas fa-music text-blue-600 mr-3"></i>
                高解像度音声波形エディタ
            </h1>
            <p class="text-gray-600">動画から音声を抽出し、詳細な波形解析と編集を行えます</p>
        </header>

        <!-- ファイルアップロード -->
        <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
            <div class="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center hover:border-blue-500 transition-colors duration-300">
                <input type="file" id="fileInput" accept="video/*" class="hidden">
                <div class="cursor-pointer" onclick="document.getElementById('fileInput').click()">
                    <i class="fas fa-cloud-upload-alt text-6xl text-gray-400 mb-4"></i>
                    <p class="text-xl text-gray-600 mb-2">動画ファイルをアップロード</p>
                    <p class="text-sm text-gray-500">MP4, AVI, MOV, WEBM などの形式に対応</p>
                    <p class="text-sm text-gray-500 mt-2">または、ファイルをここにドラッグ&ドロップ</p>
                </div>
            </div>
            <div id="uploadProgress" class="mt-4 hidden">
                <div class="bg-gray-200 rounded-full h-2">
                    <div id="progressBar" class="bg-blue-600 h-2 rounded-full transition-all duration-300" style="width: 0%"></div>
                </div>
                <p id="progressText" class="text-sm text-gray-600 mt-2">処理中...</p>
            </div>
        </div>

        <!-- メイン操作パネル -->
        <div id="mainPanel" class="hidden">
            <!-- 波形解析情報 -->
            <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
                <h3 class="text-lg font-semibold text-gray-800 mb-4">
                    <i class="fas fa-chart-line text-green-600 mr-2"></i>
                    波形解析情報
                </h3>
                <div class="grid grid-cols-2 md:grid-cols-4 gap-4">
                    <div class="text-center">
                        <p class="text-sm text-gray-600">総時間</p>
                        <p id="totalDuration" class="text-xl font-bold text-blue-600">--:--</p>
                    </div>
                    <div class="text-center">
                        <p class="text-sm text-gray-600">最大振幅</p>
                        <p id="maxAmplitude" class="text-xl font-bold text-green-600">-</p>
                    </div>
                    <div class="text-center">
                        <p class="text-sm text-gray-600">RMS値</p>
                        <p id="rmsValue" class="text-xl font-bold text-yellow-600">-</p>
                    </div>
                    <div class="text-center">
                        <p class="text-sm text-gray-600">サンプルレート</p>
                        <p id="sampleRate" class="text-xl font-bold text-purple-600">-</p>
                    </div>
                </div>
            </div>

            <!-- 時間表示 -->
            <div class="bg-white rounded-lg shadow-lg p-4 mb-6">
                <div class="flex justify-between items-center">
                    <div class="text-center">
                        <p class="text-sm text-gray-600">現在時間</p>
                        <p id="currentTime" class="text-2xl font-mono font-bold text-blue-600">00:00.000</p>
                    </div>
                    <div class="text-center">
                        <p class="text-sm text-gray-600">選択範囲</p>
                        <p id="selectionTime" class="text-lg font-mono font-bold text-green-600">未選択</p>
                    </div>
                    <div class="text-center">
                        <p class="text-sm text-gray-600">音量レベル</p>
                        <div class="w-32 h-4 bg-gray-200 rounded-full overflow-hidden">
                            <div id="volumeMeter" class="volume-meter h-full w-0 transition-all duration-100"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- 波形表示 -->
            <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
                <div class="flex justify-between items-center mb-4">
                    <h3 class="text-lg font-semibold text-gray-800">
                        <i class="fas fa-waveform-path text-blue-600 mr-2"></i>
                        高解像度波形
                    </h3>
                    <div class="flex items-center space-x-4">
                        <div class="flex items-center space-x-2">
                            <label class="text-sm text-gray-600">ズーム:</label>
                            <input type="range" id="zoomSlider" min="1" max="50" value="1" class="w-32">
                            <span id="zoomLevel" class="text-sm font-mono text-gray-600">1x</span>
                        </div>
                        <button id="resetZoom" class="px-3 py-1 bg-gray-500 text-white rounded hover:bg-gray-600 transition-colors">
                            <i class="fas fa-expand-arrows-alt mr-1"></i>リセット
                        </button>
                    </div>
                </div>
                <div class="waveform-container bg-gray-50 rounded border" style="height: 300px;">
                    <canvas id="waveformCanvas" class="w-full h-full"></canvas>
                    <div id="playhead" class="playhead"></div>
                    <div id="selectionOverlay" class="selection-overlay hidden"></div>
                </div>
                <div class="mt-2 text-xs text-gray-500 text-center">
                    マウスホイール: ズーム | ドラッグ: 範囲選択 | クリック: 再生位置移動
                </div>
            </div>

            <!-- 再生コントロール -->
            <div class="bg-white rounded-lg shadow-lg p-6 mb-6">
                <h3 class="text-lg font-semibold text-gray-800 mb-4">
                    <i class="fas fa-play-circle text-green-600 mr-2"></i>
                    再生コントロール
                </h3>
                <div class="flex items-center justify-center space-x-4 mb-6">
                    <button id="playPauseBtn" class="px-6 py-3 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors text-lg">
                        <i class="fas fa-play mr-2"></i>再生
                    </button>
                    <button id="stopBtn" class="px-4 py-3 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors">
                        <i class="fas fa-stop mr-2"></i>停止
                    </button>
                    <button id="loopBtn" class="px-4 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors">
                        <i class="fas fa-sync mr-2"></i>ループ
                    </button>
                </div>
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">再生速度</label>
                        <select id="playbackRate" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                            <option value="0.5">0.5x</option>
                            <option value="1" selected>1.0x (標準)</option>
                            <option value="1.25">1.25x</option>
                            <option value="1.5">1.5x</option>
                            <option value="2">2.0x</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">音量</label>
                        <input type="range" id="volumeSlider" min="0" max="100" value="80" class="w-full">
                    </div>
                </div>
            </div>

            <!-- エクスポート設定 -->
            <div class="bg-white rounded-lg shadow-lg p-6">
                <h3 class="text-lg font-semibold text-gray-800 mb-4">
                    <i class="fas fa-download text-purple-600 mr-2"></i>
                    エクスポート設定
                </h3>
                <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-6">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">出力形式</label>
                        <select id="exportFormat" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                            <option value="wav">WAV (無圧縮)</option>
                            <option value="mp3">MP3 (圧縮)</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">品質</label>
                        <select id="exportQuality" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                            <option value="high">高品質</option>
                            <option value="medium" selected>標準品質</option>
                            <option value="low">低品質</option>
                        </select>
                    </div>
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-2">エクスポート範囲</label>
                        <select id="exportRange" class="w-full p-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent">
                            <option value="full">全体</option>
                            <option value="selection">選択範囲</option>
                        </select>
                    </div>
                </div>
                <div class="flex justify-center space-x-4">
                    <button id="exportBtn" class="px-6 py-3 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors">
                        <i class="fas fa-download mr-2"></i>音声をダウンロード
                    </button>
                    <button id="exportSelectionBtn" class="px-6 py-3 bg-indigo-600 text-white rounded-lg hover:bg-indigo-700 transition-colors">
                        <i class="fas fa-cut mr-2"></i>選択部分をダウンロード
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        class AdvancedAudioExtractor {
            constructor() {
                this.initializeElements();
                this.initializeAudio();
                this.setupEventListeners();
                this.waveformData = null;
                this.audioBuffer = null;
                this.audioSource = null;
                this.isPlaying = false;
                this.isLooping = false;
                this.startTime = 0;
                this.pauseTime = 0;
                this.zoomLevel = 1;
                this.panOffset = 0;
                this.selection = { start: -1, end: -1 };
                this.animationId = null;
            }

            initializeElements() {
                this.fileInput = document.getElementById('fileInput');
                this.uploadProgress = document.getElementById('uploadProgress');
                this.progressBar = document.getElementById('progressBar');
                this.progressText = document.getElementById('progressText');
                this.mainPanel = document.getElementById('mainPanel');
                this.waveformCanvas = document.getElementById('waveformCanvas');
                this.ctx = this.waveformCanvas.getContext('2d');
                this.playhead = document.getElementById('playhead');
                this.selectionOverlay = document.getElementById('selectionOverlay');
                this.playPauseBtn = document.getElementById('playPauseBtn');
                this.stopBtn = document.getElementById('stopBtn');
                this.loopBtn = document.getElementById('loopBtn');
                this.playbackRate = document.getElementById('playbackRate');
                this.volumeSlider = document.getElementById('volumeSlider');
                this.zoomSlider = document.getElementById('zoomSlider');
                this.zoomLevel = document.getElementById('zoomLevel');
                this.resetZoom = document.getElementById('resetZoom');
                this.exportBtn = document.getElementById('exportBtn');
                this.exportSelectionBtn = document.getElementById('exportSelectionBtn');
                this.totalDuration = document.getElementById('totalDuration');
                this.maxAmplitude = document.getElementById('maxAmplitude');
                this.rmsValue = document.getElementById('rmsValue');
                this.sampleRate = document.getElementById('sampleRate');
                this.currentTime = document.getElementById('currentTime');
                this.selectionTime = document.getElementById('selectionTime');
                this.volumeMeter = document.getElementById('volumeMeter');
                this.exportFormat = document.getElementById('exportFormat');
                this.exportQuality = document.getElementById('exportQuality');
                this.exportRange = document.getElementById('exportRange');
            }

            initializeAudio() {
                this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                this.analyser = this.audioContext.createAnalyser();
                this.gainNode = this.audioContext.createGain();
                this.analyser.fftSize = 2048;
                this.analyser.connect(this.gainNode);
                this.gainNode.connect(this.audioContext.destination);
            }

            setupEventListeners() {
                // ファイル関連
                this.fileInput.addEventListener('change', (e) => this.handleFile(e.target.files[0]));
                document.addEventListener('dragover', (e) => e.preventDefault());
                document.addEventListener('drop', (e) => {
                    e.preventDefault();
                    if (e.dataTransfer.files.length > 0) {
                        this.handleFile(e.dataTransfer.files[0]);
                    }
                });

                // 再生コントロール
                this.playPauseBtn.addEventListener('click', () => this.togglePlayPause());
                this.stopBtn.addEventListener('click', () => this.stop());
                this.loopBtn.addEventListener('click', () => this.toggleLoop());
                this.playbackRate.addEventListener('change', (e) => this.setPlaybackRate(e.target.value));
                this.volumeSlider.addEventListener('input', (e) => this.setVolume(e.target.value));

                // 波形コントロール
                this.zoomSlider.addEventListener('input', (e) => this.setZoom(e.target.value));
                this.resetZoom.addEventListener('click', () => this.resetZoomAndPan());
                this.waveformCanvas.addEventListener('click', (e) => this.handleCanvasClick(e));
                this.waveformCanvas.addEventListener('mousedown', (e) => this.startSelection(e));
                this.waveformCanvas.addEventListener('mousemove', (e) => this.updateSelection(e));
                this.waveformCanvas.addEventListener('mouseup', () => this.endSelection());
                this.waveformCanvas.addEventListener('wheel', (e) => this.handleWheel(e));

                // エクスポート
                this.exportBtn.addEventListener('click', () => this.exportAudio());
                this.exportSelectionBtn.addEventListener('click', () => this.exportSelection());

                // リサイズ対応
                window.addEventListener('resize', () => this.resizeCanvas());
            }

            async handleFile(file) {
                if (!file) return;

                this.showProgress('ファイルを読み込み中...');
                
                try {
                    const arrayBuffer = await file.arrayBuffer();
                    this.showProgress('音声を抽出中...');
                    
                    const audioBuffer = await this.audioContext.decodeAudioData(arrayBuffer);
                    this.audioBuffer = audioBuffer;
                    
                    this.showProgress('波形を解析中...');
                    await this.analyzeAudio(audioBuffer);
                    
                    this.hideProgress();
                    this.mainPanel.classList.remove('hidden');
                    this.resizeCanvas();
                    this.drawWaveform();
                    
                } catch (error) {
                    console.error('音声処理エラー:', error);
                    this.hideProgress();
                    alert('音声の処理中にエラーが発生しました。対応している動画ファイルを選択してください。');
                }
            }

            async analyzeAudio(audioBuffer) {
                const channelData = audioBuffer.getChannelData(0);
                this.waveformData = channelData;
                
                // 波形解析
                let maxAmp = 0;
                let sumSquares = 0;
                
                for (let i = 0; i < channelData.length; i++) {
                    const sample = Math.abs(channelData[i]);
                    if (sample > maxAmp) maxAmp = sample;
                    sumSquares += channelData[i] * channelData[i];
                }
                
                const rms = Math.sqrt(sumSquares / channelData.length);
                
                // 情報を表示
                this.totalDuration.textContent = this.formatTime(audioBuffer.duration);
                this.maxAmplitude.textContent = maxAmp.toFixed(3);
                this.rmsValue.textContent = rms.toFixed(3);
                this.sampleRate.textContent = `${audioBuffer.sampleRate} Hz`;
                
                return true;
            }

            showProgress(text) {
                this.uploadProgress.classList.remove('hidden');
                this.progressText.textContent = text;
                this.progressBar.style.width = '100%';
            }

            hideProgress() {
                this.uploadProgress.classList.add('hidden');
                this.progressBar.style.width = '0%';
            }

            resizeCanvas() {
                const rect = this.waveformCanvas.getBoundingClientRect();
                this.waveformCanvas.width = rect.width * window.devicePixelRatio;
                this.waveformCanvas.height = rect.height * window.devicePixelRatio;
                this.ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
                
                if (this.waveformData) {
                    this.drawWaveform();
                }
            }

            drawWaveform() {
                if (!this.waveformData) return;

                const canvas = this.waveformCanvas;
                const ctx = this.ctx;
                const width = canvas.width / window.devicePixelRatio;
                const height = canvas.height / window.devicePixelRatio;
                
                ctx.clearRect(0, 0, width, height);
                
                // 背景
                ctx.fillStyle = '#f9fafb';
                ctx.fillRect(0, 0, width, height);
                
                // 中央線
                ctx.strokeStyle = '#e5e7eb';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(0, height / 2);
                ctx.lineTo(width, height / 2);
                ctx.stroke();
                
                // 波形描画
                const samplesPerPixel = Math.max(1, Math.floor(this.waveformData.length / (width * this.zoom)));
                const startSample = Math.floor(this.panOffset * this.waveformData.length);
                
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 1;
                ctx.beginPath();
                
                for (let x = 0; x < width; x++) {
                    const sampleIndex = startSample + x * samplesPerPixel;
                    if (sampleIndex >= this.waveformData.length) break;
                    
                    let min = 0, max = 0;
                    for (let s = 0; s < samplesPerPixel && sampleIndex + s < this.waveformData.length; s++) {
                        const sample = this.waveformData[sampleIndex + s];
                        if (sample < min) min = sample;
                        if (sample > max) max = sample;
                    }
                    
                    const y1 = (height / 2) + (min * height / 2);
                    const y2 = (height / 2) + (max * height / 2);
                    
                    if (x === 0) {
                        ctx.moveTo(x, y1);
                    }
                    ctx.lineTo(x, y1);
                    ctx.lineTo(x, y2);
                }
                
                ctx.stroke();
                
                // 時間マーカー
                this.drawTimeMarkers(width, height);
            }

            drawTimeMarkers(width, height) {
                if (!this.audioBuffer) return;
                
                const ctx = this.ctx;
                const duration = this.audioBuffer.duration;
                const visibleDuration = duration / this.zoom;
                const startTime = this.panOffset * duration;
                
                ctx.fillStyle = '#6b7280';
                ctx.font = '10px monospace';
                
                const markerInterval = this.getMarkerInterval(visibleDuration);
                const startMarker = Math.ceil(startTime / markerInterval) * markerInterval;
                
                for (let time = startMarker; time <= startTime + visibleDuration; time += markerInterval) {
                    const x = ((time - startTime) / visibleDuration) * width;
                    
                    // マーカー線
                    ctx.strokeStyle = '#d1d5db';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, height);
                    ctx.stroke();
                    
                    // 時間ラベル
                    ctx.fillText(this.formatTime(time), x + 2, 12);
                }
            }

            getMarkerInterval(duration) {
                if (duration <= 10) return 1;
                if (duration <= 60) return 5;
                if (duration <= 300) return 30;
                if (duration <= 1800) return 60;
                return 300;
            }

            handleCanvasClick(e) {
                if (!this.audioBuffer) return;
                
                const rect = this.waveformCanvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const progress = x / rect.width;
                const duration = this.audioBuffer.duration;
                const visibleDuration = duration / this.zoom;
                const startTime = this.panOffset * duration;
                const clickTime = startTime + (progress * visibleDuration);
                
                this.seekTo(clickTime);
            }

            startSelection(e) {
                if (!this.audioBuffer) return;
                
                this.isSelecting = true;
                const rect = this.waveformCanvas.getBoundingClientRect();
                this.selectionStart = e.clientX - rect.left;
                this.selection.start = this.pixelToTime(this.selectionStart);
                
                document.addEventListener('mousemove', this.boundUpdateSelection);
                document.addEventListener('mouseup', this.boundEndSelection);
            }

            updateSelection(e) {
                if (!this.isSelecting || !this.audioBuffer) return;
                
                const rect = this.waveformCanvas.getBoundingClientRect();
                const currentX = e.clientX - rect.left;
                this.selectionEnd = currentX;
                this.selection.end = this.pixelToTime(currentX);
                
                this.updateSelectionOverlay();
                this.updateSelectionTime();
            }

            endSelection() {
                this.isSelecting = false;
                document.removeEventListener('mousemove', this.boundUpdateSelection);
                document.removeEventListener('mouseup', this.boundEndSelection);
                
                if (this.selection.start > this.selection.end) {
                    [this.selection.start, this.selection.end] = [this.selection.end, this.selection.start];
                }
            }

            pixelToTime(x) {
                const rect = this.waveformCanvas.getBoundingClientRect();
                const progress = x / rect.width;
                const duration = this.audioBuffer.duration;
                const visibleDuration = duration / this.zoom;
                const startTime = this.panOffset * duration;
                return startTime + (progress * visibleDuration);
            }

            updateSelectionOverlay() {
                if (this.selection.start === -1 || this.selection.end === -1) {
                    this.selectionOverlay.classList.add('hidden');
                    return;
                }
                
                const rect = this.waveformCanvas.getBoundingClientRect();
                const duration = this.audioBuffer.duration;
                const visibleDuration = duration / this.zoom;
                const startTime = this.panOffset * duration;
                
                const startX = ((this.selection.start - startTime) / visibleDuration) * rect.width;
                const endX = ((this.selection.end - startTime) / visibleDuration) * rect.width;
                
                this.selectionOverlay.style.left = `${Math.min(startX, endX)}px`;
                this.selectionOverlay.style.width = `${Math.abs(endX - startX)}px`;
                this.selectionOverlay.style.height = `${rect.height}px`;
                this.selectionOverlay.classList.remove('hidden');
            }

            updateSelectionTime() {
                if (this.selection.start === -1 || this.selection.end === -1) {
                    this.selectionTime.textContent = '未選択';
                    return;
                }
                
                const duration = Math.abs(this.selection.end - this.selection.start);
                this.selectionTime.textContent = this.formatTime(duration);
            }

            handleWheel(e) {
                e.preventDefault();
                const zoomDelta = e.deltaY > 0 ? 0.9 : 1.1;
                const newZoom = Math.max(1, Math.min(50, this.zoom * zoomDelta));
                this.setZoom(newZoom);
                this.zoomSlider.value = newZoom;
            }

            setZoom(value) {
                this.zoom = parseFloat(value);
                this.zoomLevel.textContent = `${this.zoom.toFixed(1)}x`;
                this.drawWaveform();
                this.updateSelectionOverlay();
            }

            resetZoomAndPan() {
                this.zoom = 1;
                this.panOffset = 0;
                this.zoomSlider.value = 1;
                this.setZoom(1);
            }

            async togglePlayPause() {
                if (!this.audioBuffer) return;
                
                if (this.isPlaying) {
                    this.pause();
                } else {
                    await this.play();
                }
            }

            async play() {
                if (this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }
                
                this.stop();
                
                this.audioSource = this.audioContext.createBufferSource();
                this.audioSource.buffer = this.audioBuffer;
                this.audioSource.connect(this.analyser);
                this.audioSource.loop = this.isLooping;
                
                const rate = parseFloat(this.playbackRate.value);
                this.audioSource.playbackRate.value = rate;
                
                const currentTime = this.pauseTime || 0;
                this.audioSource.start(0, currentTime);
                this.startTime = this.audioContext.currentTime - currentTime;
                
                this.isPlaying = true;
                this.playPauseBtn.innerHTML = '<i class="fas fa-pause mr-2"></i>一時停止';
                
                this.audioSource.onended = () => {
                    if (!this.isLooping) {
                        this.stop();
                    }
                };
                
                this.startVisualization();
            }

            pause() {
                if (this.audioSource) {
                    this.pauseTime = this.audioContext.currentTime - this.startTime;
                    this.audioSource.stop();
                    this.audioSource = null;
                }
                
                this.isPlaying = false;
                this.playPauseBtn.innerHTML = '<i class="fas fa-play mr-2"></i>再生';
                this.stopVisualization();
            }

            stop() {
                if (this.audioSource) {
                    this.audioSource.stop();
                    this.audioSource = null;
                }
                
                this.isPlaying = false;
                this.pauseTime = 0;
                this.startTime = 0;
                this.playPauseBtn.innerHTML = '<i class="fas fa-play mr-2"></i>再生';
                this.stopVisualization();
                this.updatePlayhead(0);
            }

            toggleLoop() {
                this.isLooping = !this.isLooping;
                this.loopBtn.classList.toggle('bg-blue-600', this.isLooping);
                this.loopBtn.classList.toggle('bg-blue-800', this.isLooping);
                
                if (this.audioSource) {
                    this.audioSource.loop = this.isLooping;
                }
            }

            setPlaybackRate(rate) {
                if (this.audioSource) {
                    this.audioSource.playbackRate.value = parseFloat(rate);
                }
            }

            setVolume(value) {
                this.gainNode.gain.value = value / 100;
            }

            seekTo(time) {
                const clampedTime = Math.max(0, Math.min(this.audioBuffer.duration, time));
                
                if (this.isPlaying) {
                    this.pauseTime = clampedTime;
                    this.play();
                } else {
                    this.pauseTime = clampedTime;
                    this.updatePlayhead(clampedTime);
                }
            }

            startVisualization() {
                const animate = () => {
                    if (!this.isPlaying) return;
                    
                    const currentTime = this.audioContext.currentTime - this.startTime;
                    this.updatePlayhead(currentTime);
                    this.updateCurrentTime(currentTime);
                    this.updateVolumeMeter();
                    
                    this.animationId = requestAnimationFrame(animate);
                };
                animate();
            }

            stopVisualization() {
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                    this.animationId = null;
                }
            }

            updatePlayhead(time) {
                if (!this.audioBuffer) return;
                
                const duration = this.audioBuffer.duration;
                const visibleDuration = duration / this.zoom;
                const startTime = this.panOffset * duration;
                const progress = (time - startTime) / visibleDuration;
                const rect = this.waveformCanvas.getBoundingClientRect();
                
                if (progress >= 0 && progress <= 1) {
                    this.playhead.style.left = `${progress * rect.width}px`;
                    this.playhead.style.height = `${rect.height}px`;
                    this.playhead.style.display = 'block';
                } else {
                    this.playhead.style.display = 'none';
                }
            }

            updateCurrentTime(time) {
                this.currentTime.textContent = this.formatTimeDetailed(time);
            }

            updateVolumeMeter() {
                const bufferLength = this.analyser.frequencyBinCount;
                const dataArray = new Uint8Array(bufferLength);
                this.analyser.getByteFrequencyData(dataArray);
                
                let sum = 0;
                for (let i = 0; i < bufferLength; i++) {
                    sum += dataArray[i];
                }
                const average = sum / bufferLength;
                const percentage = (average / 255) * 100;
                
                this.volumeMeter.style.width = `${percentage}%`;
            }

            async exportAudio() {
                if (!this.audioBuffer) return;
                
                const format = this.exportFormat.value;
                const quality = this.exportQuality.value;
                
                const audioData = this.audioBuffer.getChannelData(0);
                const wav = this.encodeWAV(audioData, this.audioBuffer.sampleRate);
                
                const blob = new Blob([wav], { type: 'audio/wav' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `extracted_audio.${format}`;
                a.click();
                
                URL.revokeObjectURL(url);
            }

            async exportSelection() {
                if (!this.audioBuffer || this.selection.start === -1 || this.selection.end === -1) {
                    alert('選択範囲を指定してください。');
                    return;
                }
                
                const sampleRate = this.audioBuffer.sampleRate;
                const startSample = Math.floor(this.selection.start * sampleRate);
                const endSample = Math.floor(this.selection.end * sampleRate);
                const selectionLength = endSample - startSample;
                
                const originalData = this.audioBuffer.getChannelData(0);
                const selectionData = originalData.slice(startSample, endSample);
                
                const wav = this.encodeWAV(selectionData, sampleRate);
                const blob = new Blob([wav], { type: 'audio/wav' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = `selection_${this.formatTime(this.selection.start)}-${this.formatTime(this.selection.end)}.wav`;
                a.click();
                
                URL.revokeObjectURL(url);
            }

            encodeWAV(samples, sampleRate) {
                const buffer = new ArrayBuffer(44 + samples.length * 2);
                const view = new DataView(buffer);
                
                const writeString = (offset, string) => {
                    for (let i = 0; i < string.length; i++) {
                        view.setUint8(offset + i, string.charCodeAt(i));
                    }
                };
                
                writeString(0, 'RIFF');
                view.setUint32(4, 36 + samples.length * 2, true);
                writeString(8, 'WAVE');
                writeString(12, 'fmt ');
                view.setUint32(16, 16, true);
                view.setUint16(20, 1, true);
                view.setUint16(22, 1, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, sampleRate * 2, true);
                view.setUint16(32, 2, true);
                view.setUint16(34, 16, true);
                writeString(36, 'data');
                view.setUint32(40, samples.length * 2, true);
                
                const offset = 44;
                for (let i = 0; i < samples.length; i++) {
                    const sample = Math.max(-1, Math.min(1, samples[i]));
                    view.setInt16(offset + i * 2, sample * 0x7FFF, true);
                }
                
                return buffer;
            }

            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins}:${secs.toString().padStart(2, '0')}`;
            }

            formatTimeDetailed(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                const ms = Math.floor((seconds % 1) * 1000);
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}.${ms.toString().padStart(3, '0')}`;
            }
        }

        // アプリケーション初期化
        document.addEventListener('DOMContentLoaded', () => {
            new AdvancedAudioExtractor();
        });
    </script>
<script defer src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015" integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==" data-cf-beacon='{"rayId":"97b246539b2b2642","serverTiming":{"name":{"cfExtPri":true,"cfEdge":true,"cfOrigin":true,"cfL4":true,"cfSpeedBrain":true,"cfCacheStatus":true}},"version":"2025.8.0","token":"4edd5f8ec12a48cfa682ab8261b80a79"}' crossorigin="anonymous"></script>
</body>
</html>
    <script id="html_badge_script1">
        window.__genspark_remove_badge_link = "https://www.genspark.ai/api/html_badge/" +
            "remove_badge?token=To%2FBnjzloZ3UfQdcSaYfDlUAkq4G1TZ6flJ7V6KVV9iNAZHYLqg8yJNVtyWb6YlaTbtoZvnfBIYcJxlrFOqXnScR3V0b4yQviGUGSSkJ5iIFN5vnwV9gEdqW1E2hVrBWbl7bFjk02OXTNb9kHVgu%2B6MNZdmuk0XlIplidm468n%2B78RTzPWfUBTUOlzB4b1kXn3tSkJq8U2Iw6dvGrx7jHYTHqdayn%2FJihn6JCTPzsZL38DEJtRDahQjYVmo4BiycVvZv4iWLHCXvA78g%2FsXOYxOqbqelicuwFOJt2p12Fkc7rT4xGcyhaD6gN1elFVBMrKFIlRSvWz5NQI2sgHmyMrilgla1kcN2hqqJiGWC2asb%2B%2BU73ImttA7GQNrNfKT8VK%2BNzX0Q68ZPyM3RE9XqS0R%2BMNNNvAiyW0fIcnnmieMKt0XcHZbarNWv9dB0aF8XdH63MLeE3oKjdMC9N9iY6EyFT8FfTaPktTXo9hbuPMObfvxVLVFdcXuwwty%2BNWpjzsN1PfFQXHCFAnAH%2B9lgRYzEK0fbUGetvS9Ro4zBZko%3D";
        window.__genspark_locale = "ja-JP";
        window.__genspark_token = "To/BnjzloZ3UfQdcSaYfDlUAkq4G1TZ6flJ7V6KVV9iNAZHYLqg8yJNVtyWb6YlaTbtoZvnfBIYcJxlrFOqXnScR3V0b4yQviGUGSSkJ5iIFN5vnwV9gEdqW1E2hVrBWbl7bFjk02OXTNb9kHVgu+6MNZdmuk0XlIplidm468n+78RTzPWfUBTUOlzB4b1kXn3tSkJq8U2Iw6dvGrx7jHYTHqdayn/Jihn6JCTPzsZL38DEJtRDahQjYVmo4BiycVvZv4iWLHCXvA78g/sXOYxOqbqelicuwFOJt2p12Fkc7rT4xGcyhaD6gN1elFVBMrKFIlRSvWz5NQI2sgHmyMrilgla1kcN2hqqJiGWC2asb++U73ImttA7GQNrNfKT8VK+NzX0Q68ZPyM3RE9XqS0R+MNNNvAiyW0fIcnnmieMKt0XcHZbarNWv9dB0aF8XdH63MLeE3oKjdMC9N9iY6EyFT8FfTaPktTXo9hbuPMObfvxVLVFdcXuwwty+NWpjzsN1PfFQXHCFAnAH+9lgRYzEK0fbUGetvS9Ro4zBZko=";
    </script>
    
    <script id="html_notice_dialog_script" src="https://www.genspark.ai/notice_dialog.js"></script>
    