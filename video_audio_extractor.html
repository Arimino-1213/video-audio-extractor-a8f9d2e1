<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>動画音声抽出＆波形表示システム</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.4.0/css/all.min.css">
    <style>
        .drag-over {
            border-color: #3b82f6 !important;
            background-color: #eff6ff !important;
        }
        
        .waveform-container {
            position: relative;
            background: linear-gradient(45deg, #f8fafc, #e2e8f0);
            border-radius: 8px;
            overflow: hidden;
        }
        
        .progress-bar {
            transition: width 0.3s ease;
        }
        
        .pulse-animation {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        .waveform-canvas {
            display: block;
            width: 100%;
            height: 200px;
            cursor: crosshair;
        }
        
        .time-indicator {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            height: 20px;
            background: rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 10px;
            font-size: 12px;
            color: #4b5563;
        }
    </style>
</head>
<body class="bg-gray-100 min-h-screen py-8">
    <div class="container mx-auto px-4 max-w-4xl">
        <div class="bg-white rounded-lg shadow-lg p-8">
            <h1 class="text-3xl font-bold text-center mb-8 text-gray-800">
                <i class="fas fa-music mr-3 text-blue-500"></i>
                動画音声抽出＆波形表示システム
            </h1>
            
            <!-- File Upload Area -->
            <div id="dropZone" class="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center mb-6 transition-all duration-300 hover:border-blue-400 hover:bg-blue-50">
                <i class="fas fa-cloud-upload-alt text-4xl text-gray-400 mb-4"></i>
                <p class="text-lg text-gray-600 mb-4">動画ファイルをドラッグ&ドロップするか、クリックして選択してください</p>
                <p class="text-sm text-gray-500 mb-4">対応形式: MP4, AVI, MOV, WEBM</p>
                <input type="file" id="videoInput" accept="video/*" class="hidden">
                <button id="selectButton" class="bg-blue-500 hover:bg-blue-600 text-white px-6 py-3 rounded-lg transition-colors duration-300">
                    <i class="fas fa-folder-open mr-2"></i>ファイルを選択
                </button>
            </div>
            
            <!-- Progress Bar -->
            <div id="progressContainer" class="hidden mb-6">
                <div class="flex justify-between items-center mb-2">
                    <span class="text-sm text-gray-600">処理中...</span>
                    <span id="progressText" class="text-sm text-gray-600">0%</span>
                </div>
                <div class="w-full bg-gray-200 rounded-full h-2">
                    <div id="progressBar" class="bg-blue-500 h-2 rounded-full progress-bar" style="width: 0%"></div>
                </div>
            </div>
            
            <!-- Video Preview -->
            <div id="videoContainer" class="hidden mb-6">
                <h3 class="text-lg font-semibold mb-3 text-gray-700">
                    <i class="fas fa-video mr-2"></i>動画プレビュー
                </h3>
                <video id="videoPreview" controls playsinline webkit-playsinline class="w-full rounded-lg shadow-md">
                </video>
            </div>
            
            <!-- Waveform Display -->
            <div id="waveformContainer" class="hidden mb-6">
                <h3 class="text-lg font-semibold mb-3 text-gray-700">
                    <i class="fas fa-wave-square mr-2"></i>音声波形
                </h3>
                <div class="waveform-container">
                    <canvas id="waveformCanvas" class="waveform-canvas"></canvas>
                    <div class="time-indicator">
                        <span id="currentTime">00:00</span>
                        <span id="duration">00:00</span>
                    </div>
                </div>
                
                <!-- Audio Controls -->
                <div class="flex justify-center items-center mt-4 space-x-4">
                    <button id="playPauseBtn" class="bg-green-500 hover:bg-green-600 text-white px-4 py-2 rounded-lg transition-colors duration-300">
                        <i class="fas fa-play mr-2"></i>再生
                    </button>
                    <button id="stopBtn" class="bg-red-500 hover:bg-red-600 text-white px-4 py-2 rounded-lg transition-colors duration-300">
                        <i class="fas fa-stop mr-2"></i>停止
                    </button>
                </div>
            </div>
            
            <!-- Download Section -->
            <div id="downloadContainer" class="hidden text-center">
                <button id="downloadBtn" class="bg-purple-500 hover:bg-purple-600 text-white px-6 py-3 rounded-lg transition-colors duration-300 text-lg">
                    <i class="fas fa-download mr-2"></i>音声をダウンロード (WAV)
                </button>
            </div>
            
            <!-- Status Messages -->
            <div id="statusContainer" class="mt-6 hidden">
                <div id="statusMessage" class="p-4 rounded-lg"></div>
            </div>
        </div>
    </div>

    <script>
        class VideoAudioExtractor {
            constructor() {
                this.audioContext = null;
                this.audioBuffer = null;
                this.audioSource = null;
                this.isPlaying = false;
                this.currentTime = 0;
                this.duration = 0;
                this.animationId = null;
                
                this.initializeElements();
                this.setupEventListeners();
            }
            
            initializeElements() {
                this.dropZone = document.getElementById('dropZone');
                this.videoInput = document.getElementById('videoInput');
                this.selectButton = document.getElementById('selectButton');
                this.progressContainer = document.getElementById('progressContainer');
                this.progressBar = document.getElementById('progressBar');
                this.progressText = document.getElementById('progressText');
                this.videoContainer = document.getElementById('videoContainer');
                this.videoPreview = document.getElementById('videoPreview');
                this.waveformContainer = document.getElementById('waveformContainer');
                this.waveformCanvas = document.getElementById('waveformCanvas');
                this.downloadContainer = document.getElementById('downloadContainer');
                this.downloadBtn = document.getElementById('downloadBtn');
                this.statusContainer = document.getElementById('statusContainer');
                this.statusMessage = document.getElementById('statusMessage');
                this.playPauseBtn = document.getElementById('playPauseBtn');
                this.stopBtn = document.getElementById('stopBtn');
                this.currentTimeSpan = document.getElementById('currentTime');
                this.durationSpan = document.getElementById('duration');
                
                this.ctx = this.waveformCanvas.getContext('2d');
            }
            
            setupEventListeners() {
                // Drag and drop
                this.dropZone.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    this.dropZone.classList.add('drag-over');
                });
                
                this.dropZone.addEventListener('dragleave', () => {
                    this.dropZone.classList.remove('drag-over');
                });
                
                this.dropZone.addEventListener('drop', (e) => {
                    e.preventDefault();
                    this.dropZone.classList.remove('drag-over');
                    const files = e.dataTransfer.files;
                    if (files.length > 0) {
                        this.handleFile(files[0]);
                    }
                });
                
                // File selection
                this.selectButton.addEventListener('click', () => {
                    this.videoInput.click();
                });
                
                this.videoInput.addEventListener('change', (e) => {
                    if (e.target.files.length > 0) {
                        this.handleFile(e.target.files[0]);
                    }
                });
                
                // Audio controls
                this.playPauseBtn.addEventListener('click', () => {
                    this.togglePlayPause();
                });
                
                this.stopBtn.addEventListener('click', () => {
                    this.stopAudio();
                });
                
                // Download
                this.downloadBtn.addEventListener('click', () => {
                    this.downloadAudio();
                });
                
                // Canvas click for seeking
                this.waveformCanvas.addEventListener('click', (e) => {
                    this.seekAudio(e);
                });
            }
            
            async handleFile(file) {
                if (!file.type.startsWith('video/')) {
                    this.showStatus('エラー: 動画ファイルを選択してください。', 'error');
                    return;
                }
                
                this.showProgress();
                this.updateProgress(10, '動画を読み込み中...');
                
                try {
                    // Show video preview
                    const videoURL = URL.createObjectURL(file);
                    this.videoPreview.src = videoURL;
                    this.videoContainer.classList.remove('hidden');
                    
                    this.updateProgress(30, '音声を抽出中...');
                    
                    // Extract audio
                    await this.extractAudio(file);
                    
                    this.updateProgress(100, '完了');
                    setTimeout(() => {
                        this.hideProgress();
                        this.showStatus('音声の抽出が完了しました！', 'success');
                    }, 500);
                    
                } catch (error) {
                    this.hideProgress();
                    this.showStatus(`エラー: ${error.message}`, 'error');
                    console.error('Error processing file:', error);
                }
            }
            
            async extractAudio(file) {
                return new Promise((resolve, reject) => {
                    const video = document.createElement('video');
                    video.src = URL.createObjectURL(file);
                    
                    video.addEventListener('loadedmetadata', async () => {
                        try {
                            this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                            
                            // Create audio buffer from video
                            const fileBuffer = await file.arrayBuffer();
                            this.audioBuffer = await this.audioContext.decodeAudioData(fileBuffer);
                            
                            this.duration = this.audioBuffer.duration;
                            this.updateProgress(60, '波形を生成中...');
                            
                            // Draw waveform
                            this.drawWaveform();
                            
                            this.updateProgress(80, '準備中...');
                            
                            // Show controls
                            this.waveformContainer.classList.remove('hidden');
                            this.downloadContainer.classList.remove('hidden');
                            
                            this.updateDurationDisplay();
                            
                            resolve();
                        } catch (error) {
                            reject(error);
                        }
                    });
                    
                    video.addEventListener('error', () => {
                        reject(new Error('動画ファイルの読み込みに失敗しました。'));
                    });
                });
            }
            
            drawWaveform() {
                const canvas = this.waveformCanvas;
                const ctx = this.ctx;
                
                // Set canvas size
                canvas.width = canvas.offsetWidth * 2; // For retina displays
                canvas.height = canvas.offsetHeight * 2;
                ctx.scale(2, 2);
                
                const width = canvas.offsetWidth;
                const height = canvas.offsetHeight;
                
                // Clear canvas
                ctx.clearRect(0, 0, width, height);
                
                if (!this.audioBuffer) return;
                
                const data = this.audioBuffer.getChannelData(0);
                const step = Math.ceil(data.length / width);
                const amp = height / 2;
                
                // Draw waveform
                ctx.fillStyle = '#3b82f6';
                ctx.strokeStyle = '#1d4ed8';
                ctx.lineWidth = 1;
                
                ctx.beginPath();
                ctx.moveTo(0, amp);
                
                for (let i = 0; i < width; i++) {
                    let min = 1.0;
                    let max = -1.0;
                    
                    for (let j = 0; j < step; j++) {
                        const datum = data[(i * step) + j];
                        if (datum < min) min = datum;
                        if (datum > max) max = datum;
                    }
                    
                    const y1 = (1 + min) * amp;
                    const y2 = (1 + max) * amp;
                    
                    ctx.fillRect(i, y1, 1, y2 - y1);
                }
                
                // Draw center line
                ctx.strokeStyle = '#e5e7eb';
                ctx.beginPath();
                ctx.moveTo(0, amp);
                ctx.lineTo(width, amp);
                ctx.stroke();
            }
            
            drawPlaybackPosition() {
                if (!this.audioBuffer) return;
                
                const canvas = this.waveformCanvas;
                const ctx = this.ctx;
                const width = canvas.offsetWidth;
                const height = canvas.offsetHeight;
                
                // Redraw waveform
                this.drawWaveform();
                
                // Draw playback position
                const position = (this.currentTime / this.duration) * width;
                ctx.strokeStyle = '#ef4444';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(position, 0);
                ctx.lineTo(position, height);
                ctx.stroke();
            }
            
            async togglePlayPause() {
                if (!this.audioBuffer) return;
                
                if (this.isPlaying) {
                    this.pauseAudio();
                } else {
                    this.playAudio();
                }
            }
            
            async playAudio() {
                if (!this.audioContext || !this.audioBuffer) return;
                
                if (this.audioContext.state === 'suspended') {
                    await this.audioContext.resume();
                }
                
                this.audioSource = this.audioContext.createBufferSource();
                this.audioSource.buffer = this.audioBuffer;
                this.audioSource.connect(this.audioContext.destination);
                
                const startTime = this.audioContext.currentTime;
                const offset = this.currentTime;
                
                this.audioSource.start(0, offset);
                this.startTime = startTime - offset;
                
                this.audioSource.onended = () => {
                    this.stopAudio();
                };
                
                this.isPlaying = true;
                this.playPauseBtn.innerHTML = '<i class="fas fa-pause mr-2"></i>一時停止';
                
                this.updatePlaybackPosition();
            }
            
            pauseAudio() {
                if (this.audioSource) {
                    this.audioSource.stop();
                    this.audioSource = null;
                }
                
                this.isPlaying = false;
                this.playPauseBtn.innerHTML = '<i class="fas fa-play mr-2"></i>再生';
                
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
            }
            
            stopAudio() {
                this.pauseAudio();
                this.currentTime = 0;
                this.updateTimeDisplay();
                this.drawPlaybackPosition();
            }
            
            updatePlaybackPosition() {
                if (!this.isPlaying) return;
                
                this.currentTime = this.audioContext.currentTime - this.startTime;
                
                if (this.currentTime >= this.duration) {
                    this.stopAudio();
                    return;
                }
                
                this.updateTimeDisplay();
                this.drawPlaybackPosition();
                
                this.animationId = requestAnimationFrame(() => {
                    this.updatePlaybackPosition();
                });
            }
            
            seekAudio(event) {
                if (!this.audioBuffer) return;
                
                const rect = this.waveformCanvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const percentage = x / rect.width;
                
                this.currentTime = percentage * this.duration;
                
                if (this.isPlaying) {
                    this.pauseAudio();
                    this.playAudio();
                } else {
                    this.updateTimeDisplay();
                    this.drawPlaybackPosition();
                }
            }
            
            updateTimeDisplay() {
                this.currentTimeSpan.textContent = this.formatTime(this.currentTime);
            }
            
            updateDurationDisplay() {
                this.durationSpan.textContent = this.formatTime(this.duration);
                this.updateTimeDisplay();
            }
            
            formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = Math.floor(seconds % 60);
                return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }
            
            downloadAudio() {
                if (!this.audioBuffer) return;
                
                const wav = this.audioBufferToWav(this.audioBuffer);
                const blob = new Blob([wav], { type: 'audio/wav' });
                const url = URL.createObjectURL(blob);
                
                const a = document.createElement('a');
                a.href = url;
                a.download = 'extracted_audio.wav';
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);
                
                this.showStatus('音声ファイルのダウンロードを開始しました。', 'success');
            }
            
            audioBufferToWav(buffer) {
                const length = buffer.length;
                const numberOfChannels = buffer.numberOfChannels;
                const sampleRate = buffer.sampleRate;
                const arrayBuffer = new ArrayBuffer(44 + length * numberOfChannels * 2);
                const view = new DataView(arrayBuffer);
                
                // WAV header
                const writeString = (offset, string) => {
                    for (let i = 0; i < string.length; i++) {
                        view.setUint8(offset + i, string.charCodeAt(i));
                    }
                };
                
                writeString(0, 'RIFF');
                view.setUint32(4, 36 + length * numberOfChannels * 2, true);
                writeString(8, 'WAVE');
                writeString(12, 'fmt ');
                view.setUint32(16, 16, true);
                view.setUint16(20, 1, true);
                view.setUint16(22, numberOfChannels, true);
                view.setUint32(24, sampleRate, true);
                view.setUint32(28, sampleRate * numberOfChannels * 2, true);
                view.setUint16(32, numberOfChannels * 2, true);
                view.setUint16(34, 16, true);
                writeString(36, 'data');
                view.setUint32(40, length * numberOfChannels * 2, true);
                
                // PCM data
                let offset = 44;
                for (let i = 0; i < length; i++) {
                    for (let channel = 0; channel < numberOfChannels; channel++) {
                        const sample = Math.max(-1, Math.min(1, buffer.getChannelData(channel)[i]));
                        view.setInt16(offset, sample * 0x7FFF, true);
                        offset += 2;
                    }
                }
                
                return arrayBuffer;
            }
            
            showProgress() {
                this.progressContainer.classList.remove('hidden');
            }
            
            hideProgress() {
                this.progressContainer.classList.add('hidden');
            }
            
            updateProgress(percentage, text) {
                this.progressBar.style.width = `${percentage}%`;
                this.progressText.textContent = `${percentage}%`;
                if (text) {
                    this.progressText.textContent = text;
                }
            }
            
            showStatus(message, type) {
                const container = this.statusContainer;
                const messageElement = this.statusMessage;
                
                messageElement.textContent = message;
                messageElement.className = `p-4 rounded-lg ${
                    type === 'success' ? 'bg-green-100 text-green-800 border border-green-200' :
                    type === 'error' ? 'bg-red-100 text-red-800 border border-red-200' :
                    'bg-blue-100 text-blue-800 border border-blue-200'
                }`;
                
                container.classList.remove('hidden');
                
                setTimeout(() => {
                    container.classList.add('hidden');
                }, 5000);
            }
        }
        
        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            new VideoAudioExtractor();
        });
    </script>
<script defer src="https://static.cloudflareinsights.com/beacon.min.js/vcd15cbe7772f49c399c6a5babf22c1241717689176015" integrity="sha512-ZpsOmlRQV6y907TI0dKBHq9Md29nnaEIPlkf84rnaERnq6zvWvPUqr2ft8M1aS28oN72PdrCzSjY4U6VaAw1EQ==" data-cf-beacon='{"rayId":"97ac59b57b83d5b5","serverTiming":{"name":{"cfExtPri":true,"cfEdge":true,"cfOrigin":true,"cfL4":true,"cfSpeedBrain":true,"cfCacheStatus":true}},"version":"2025.8.0","token":"4edd5f8ec12a48cfa682ab8261b80a79"}' crossorigin="anonymous"></script>
</body>
</html>
    <script id="html_badge_script1">
        window.__genspark_remove_badge_link = "https://www.genspark.ai/api/html_badge/" +
            "remove_badge?token=To%2FBnjzloZ3UfQdcSaYfDpCqtSJr6tYqvlstpYdH8V9HkIBDF%2FUkGlNVDXiQko%2BItfD%2FKXbf%2BVvsoW6YXbS8E4hTNgbHWuvcy6UlJ4S1tfo%2BsoRAPOo%2FQZuWIM257oBAKZ%2B2278Wps99QN9huZA0CHvk2qe2UUrMvmYWWrbuEI2i1jYYLDWPSUat4IeZY31R8JfOzIG02BluF5tOWnWROi97St%2Bj3osCy2FeO2GcOtMNRfI%2FPjBvhRGa70AoSMmD7nCaachU6NY5lsuDWyyWBPFrUq9UWmG94V%2B2y7h%2B4cj8E7jFkJ5L0JYFPamlGYx7YxxIVmZKJ3ywEXF0h5eZ4gIhELHGl2UaR6c0xQrwhf%2FaVZhpQzxl6AEsA6cgbfUQ8%2FjHxKd%2BoHPT5El2cK08VGAxsppHIjoh%2F%2Fc1EUlHDgzcOo2CjCZGgKZaEi%2BiA1d1OU7fF8NW%2FUj5BA%2F2wTReiCgX22y2T4rEyHLdeUSgzTyJqo8AErFsl5UsgJZtB%2FKlkRJaHg1aNNwhnf5uhWqouQ%3D%3D";
        window.__genspark_locale = "ja-JP";
        window.__genspark_token = "To/BnjzloZ3UfQdcSaYfDpCqtSJr6tYqvlstpYdH8V9HkIBDF/UkGlNVDXiQko+ItfD/KXbf+VvsoW6YXbS8E4hTNgbHWuvcy6UlJ4S1tfo+soRAPOo/QZuWIM257oBAKZ+2278Wps99QN9huZA0CHvk2qe2UUrMvmYWWrbuEI2i1jYYLDWPSUat4IeZY31R8JfOzIG02BluF5tOWnWROi97St+j3osCy2FeO2GcOtMNRfI/PjBvhRGa70AoSMmD7nCaachU6NY5lsuDWyyWBPFrUq9UWmG94V+2y7h+4cj8E7jFkJ5L0JYFPamlGYx7YxxIVmZKJ3ywEXF0h5eZ4gIhELHGl2UaR6c0xQrwhf/aVZhpQzxl6AEsA6cgbfUQ8/jHxKd+oHPT5El2cK08VGAxsppHIjoh//c1EUlHDgzcOo2CjCZGgKZaEi+iA1d1OU7fF8NW/Uj5BA/2wTReiCgX22y2T4rEyHLdeUSgzTyJqo8AErFsl5UsgJZtB/KlkRJaHg1aNNwhnf5uhWqouQ==";
    </script>
    
    <script id="html_notice_dialog_script" src="https://www.genspark.ai/notice_dialog.js"></script>
    